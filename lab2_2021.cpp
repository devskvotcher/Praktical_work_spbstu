/*************************************************************
	Практическое занятие №2. 
	
	Инструкции (условная, выбор, циклы)
	Логические операторы, тернарный (условный) оператор 
	Побитовые операторы.
							
*************************************************************/

#include <iostream>
#include <bitset>

#define	  stop __asm nop	//с помощью директивы препроцессора задаем макроподстановку
/***************************************************************/
int main()
{
	setlocale(0, "RUS");
// ********************************************************
	//Задание 1. Условная инструкция if-else.Переключатель switch 

	//Задание 1.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует

	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	
	//Обратите внимание, что в кодировочной таблице между буквами верхнего и нижнего регистра 
        //расположены некоторые иные символы
 /* {
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch;
		std::cout << "Введите символ буквы английского языка=";
		std::cin >> ch;
		if ((static_cast<int> (ch) >= 'A' && static_cast<int> (ch) <= 90) || (static_cast<int> (ch) >= 97 && static_cast<int> (ch) <= 122))
		{
			if ((static_cast<int> (ch) >= 65 && static_cast<int> (ch) <= 90))
			{
				ch = static_cast<int> (ch) + 32;
				std::cout << "Перевод в другой регистр=" << ch;
			}
			else
			{
				ch = static_cast<int> (ch) - 32;
				std::cout << "Перевод в другой регистр=" << ch;
			}
		}
		else
		{
			std::cout << "Вы ввели некорректный символ"; 
		}

		//... изменили регистр

		// здесь проверили в отладчике значение или вывели "эхо" на экран
		stop
	}
 
	//Задание 1.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: 
	//если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
 {
		float x=0, y;
		std::cout << "Введите х=";
		std::cin >> x;
		if (x <= 0)
		{
			y = 0;
		}
		else if ((x > 0) && (x < 1))
		{
			y = x;
		}
		else
		{
			y = 1;
		}
		std::cout << "y="<< y << std::endl;

	stop
	}
 
	//Задание 1.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: 
	//в переменной cInput типа char дано значение символа,введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
 {
		char ch;
		int x=0, y;
		std::cout << "x=";
		std::cin >> x;
		std::cout << "Введите у или n в любом регистре=";
		std::cin >> ch;
		if(ch == 'Y' || ch == 'y')
		{
		ch = 'y';
		}
		else if(ch == 'N' || ch == 'n')
		{
		ch = 'n';
		}

		switch (ch)
		{
		case 'y':	
		case 'Y':
		y = x;
			std::cout << "y=" << y;
			break;
		case 'n':
		case 'N':
			y = x * 2;
			std::cout << "y=" << y;
			break;
		default:
			std::cout << "Вы ввели некорректные символы";
			break;
		}

	stop
	}

// ********************************************************
	//Задание 2. Логические операторы.
	// В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным НЕ является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.

	// Примечание: НЕ надо пользоваться инструкциями if-else, switch и тернарным оператором 
	//             НАДО написать логическое выражение в одну строку.
	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
	//	int year = 1823;
		//int year = 1824;
		//int year = 1900;
		int year = 2000;

		//Вычислили значение 
		bool isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
			
		// проверили значение в отладчике
		stop
	}


// *******************************************************
	//Задание 3. Тернарный оператор.  
	//С помощью тернарного оператора найдите максимальное из трех значений

	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
	int max = 0, x=0, y=0;
	std::cout << "x=";
	std::cin >> x;
	std::cout<<std::endl;
	std::cout << "y=";
	std::cin >> y;
	std::cout << std::endl;
	max = x > y ? (x > max ? x : max) : (y > max ? y : max);
	std::cout << "max=" << max << std::endl;;
	stop	
	}

// ********************************************************
	//Задание 4. Циклы.

	//Задание 4.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Задайте границы с помощью потока ввода (или прямо в коде).
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
	    //1) сформировать границы диапазона
		int sum = 0, top_border = 0, lower_border = 0;
		std::cout << "Верхнюю границу диапазона=";
		std::cin >> top_border;
		std::cout << std::endl;
		std::cout << "Верхнюю нижнюю границу диапазона=";
		std::cin >> lower_border;
		//2) проверить корректность значений
		if (top_border > lower_border)
		{
			for (size_t i = lower_border; i <= top_border; i++)
			{
				sum += i;
			}
		}
		else
		{
			std::cout << "Вы ввели некорректные значения, они будут инвертированы" << std::endl;
			//Хитрый пользователь хотел обмануть нас, инвертируем значения в правильные, параллельно выскажем ему свое фи.
			for (size_t i = top_border; i <= lower_border; i++)
			{
				sum += i;
			}
		}
			
		//3) вычислить сумму

		//4) проверить в отладчике значение (или вывести на консоль)
		std::cout << "Сумма в диапазоне=" << sum<<std::endl;
	stop
	}


	//Задание 4.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.

	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.

	{
		int x = 0;
		do
		{
			std::cout << "Для того что бы покинуть цикл, нужно ввести число более 10 и четное"<<std::endl<<"Введите число = ";
			std::cin >> x;
		} while (!((x >= 10) && (!(x & 1))));
		
	stop
	}

	//Задание 4.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
			int x = 0;
			float sum = 0;
			while (!(sum > 1.7))
			{
				x += 1;
				sum = sum + 1. / x;
			}
			std::cout << "Х, при котором sum > 1,7=" << x;
	stop
	}

// ********************************************************
//Задание 5 Побитовая арифметика (and, or, xor, not), сдвиги.
	//5.1 
{
	//а)Задайте значение пременной типа char с помощью потока ввода.
	//(для отладки можно задать значение с помощью числового литерала в 2-чном или 16-ричном коде)

	char val=0;
	std::cout << "Введите число=";
	std::cin >> val;
	static_cast<unsigned char>(val);
//	std::cout.unsetf(std::ios::dec);
//	std::cout.setf(std::ios::binary);
//	static_cast<unsigned int>(val);
//	std::cout<<"Число в двоичном представлении"<< std::bitset < sizeof(val) * 8 >(val);
	//б)	обнулите значение его 6-го бита
	val &= ~(1 << 6);
	stop

		//в)	определите значение его 5го бита
		val = (val >> 5) & 1;
	stop
	//г)	установите в 1 бит на 4-ой позиции   
		val |= (1 << 4);
	stop
	}

{


//5.2 
	

	//Если число кодируется более чем одним байтом, то важно, 
	//в каком порядке байты записываются в памяти компьютера или передаются по линиям связи.			//В архитектуре x86  используется порядок от младшего к старшему (англ. little-endian)
	//Для протоколов TCP/IP стандартным является порядок от старшего к младшему (англ. big-endian)  
	//Задайте значение x, например:

	int x = 0xA1B2C3D4;
	//байты числа в памяти следуют в порядке от младшего к старшему
	//поменяйте местами байты так, чтобы они следовали в памяти в обратном порядке 
	//(от старшего к младшему)
	//Например, если x= 0xA1B2C3D4, то после перестановки получим 0xD4C3B2A1
	static_cast<unsigned int>(x);	
	x = (x & 0x00FF00FF) << 8 | (x & 0xFF00FF00) >> 8;
	x = (x & 0x0000FFFF) << 16 | (x & 0xFFFF0000) >> 16;
	std::cout << x << std::endl;
	stop
	}

// ********************************************************
	//Задание 6 Побитовая арифметика (and, or, xor, not), сдвиги.
	//6.1 
{
	 int y;//Задайте значение y, например, с помощью потока ввода 
		   //или с помощью числового литерала в двоичном или 16-ричном виде
        //С помощью побитовых операторов и операторов сдвига:
		//выведите значение "y"  на консоль в двоичном виде, например:
		// если y==9, то 
		// 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)
	 std::cout << "Вы ввели десятичное значение=";
	 std::cin >> y;
	 std::cout << "Вы ввели десятичное значение=" << y << std::endl;

	 int current_digit;

	 for (int i = sizeof(int) * 8 - 1; i >= 0; i--)
	 {
		 current_digit = y >> i & 1;
		 std::cout << current_digit;
			
	 }

	 std::cout << std::endl;
	 system("pause");

}		
	
//6.2
{
		 
		 int y;

			//Выведите значение "y"  на консоль в двоичном виде, 
			//пропустив незначащие нули, например:
			// если y==9, то результат  1 0 0 1
		std::cout << "Вы ввели десятичное значение=";
		std::cin >> y;
		std::cout << "Вы ввели десятичное значение=" << y << std::endl;
			
bool important_zero = false;
		int current_digit;

		for (int i 		= sizeof(int) * 8 - 1; i >= 0; i--) 
		{
			if (y == 0) 
			{
				std::cout<<"0";
				break;
			}
			current_digit = y >> i & 1;
			if ((current_digit == 1) || important_zero)
			{
				std::cout<<current_digit;
				important_zero = true;
			}
		}

		std::cout << std::endl;
		system("pause");
		
}



	//6.3 (*)
/*{
		//Дана целая переменная
		int y;//Задайте значение y, например, с помощью потока ввода
		//"Сдвиньте" все единицы в этой переменной вправо, например:
	//было:   0100 1111 0000 0000 0110 1111 0000 0010
	//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	//Выведите на консоль полученное значение в двоичном виде ( можно на печати не разделять тетрады пробелом)
		std::cout << "Введите число=";
		std::cin >> y;
		int mask1=1, mask2=1;
		int current_digit=0;
		for (int i = 0; i <= ((sizeof(int) * 8) - 1); i++)
		{
			if(current_digit = y >> mask1 & 1)
			{
			mask2 = mask1 >> i & 1;
			y = y >> mask2 & 1;
			mask2<<=1;
			}
			mask1<<1;
}
*/
{
int y=0,i=31;
std::cout << "Введите число=";
std::cin >> y;
unsigned int maskLeft = 0x80000000, maskRight = 0x01;
do
{
	if ((y & maskLeft))
	{
		if (!(y & maskRight))
		{
			//y &= ~(1 << i);

			y ^= maskLeft;
			y |= maskRight;
			maskLeft >>= 1;
			maskRight <<= 1;
			//i--;
		}
		else
		{
			maskRight <<= 1;
		}
	}
	else
	{
		maskLeft >>= 1;
	}
} while (maskLeft > maskRight);
		stop
	 }

	//6.4 (*)
	//Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
		
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	
	{						  	
		short sNum = 0x8008;  //1000 0000 0000 1000
		short sRes;			  
		short sRes_1 = 0x7ff7;    //0111 1111 1111 0111
		short sRes_2 = 0x8ff8;    //1000 1111 1111 1000          маска 1111 0000 0000 1111
		short sRes_3 = 0x0008;    //0000 0000 0000 1000          маска 1000 0000 0000 0000
		short sRes_4 = 0x7f08;    //0111 1111 0000 1000          маска 1111 1111 0000 0000
		short sRes_5 = 0xf001;    //1111 0000 0000 0001			 -
		short sRes_6 = 0x0010;    //0000 0000 0001 0000          маска 1000 0000 0001 1000
		              
		sRes_1 = (~0x8008);           //1000 0000 0000 1000  0111 1111 1111 0111
		sRes_2 = (0x8008 | 0x0ff0);   //1000 0000 0000 1000  1000 1111 1111 1000 
		sRes_3 = (0x8008 & 0x000f);     //1000 0000 0000 1000  0000 0000 0000 1111
		sRes_4 = (0x8008 ^ 0xff00);     //1000 0000 0000 1000  1111 1111 0000 0000  
		sRes_5 = (0x8008 >> 3);        // 1000 0000 0000 1000  1111 0000 0000 0001                    
		
		sRes_6 = 0x8008 << 1;         //1000 0000 0000 1000  0000 0000 0001 0000 
		stop
	}


	return 0;//код завершения приложения
}	// Конец функции main()
